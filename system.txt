# Système de Combat – Documentation Technique

Ce document explique la logique complète du système de combat du projet ainsi que les liens entre les fonctions principales.

## 1. Déclenchement du Combat
- **Rencontre aléatoire** :
  - `verifierRencontre()` (combat_manager_logic.js) : Décrémente un compteur de déplacements sans rencontre. Quand il atteint 0, une rencontre peut être générée (appel API) et un monstre est placé près du joueur. Appelle ensuite `demarrerCombat()`.
- **Contact direct/adjacent** :
  - `triggerCombatIfNeeded()` (input_handler_logic.js) : Si un monstre est sur la case du joueur ou adjacent, déclenche `demarrerCombat()`.

## 2. Démarrage du Combat
- `demarrerCombat(monstre, pv, x, y)` (combat_manager_logic.js) :
  - Active le mode combat (`combatActif`)
  - Stocke le monstre courant
  - Lance une boucle d’attaque automatique du monstre (toutes les 2s : appel à `attaqueJoueur()`)

## 3. Attaque et Défense
- **Attaque du joueur** :
  - Via un talent (touche clavier, voir `handleKeydown()` et `utiliserTalent()`)
  - `utiliserTalent(talent, index)` (player_main_logic.js) :
    - Vérifie mana/cooldown, applique effets visuels
    - Si le talent est offensif, calcule les dégâts et appelle `modules.recevoirDegats()` (qui applique les dégâts au monstre)
    - Gère aussi les effets spéciaux (poison, boost, heal)
- **Attaque du monstre** :
  - `attaqueJoueur(monstre)` (combat_manager_logic.js) :
    - Calcule les dégâts infligés au joueur (attaque monstre – défense joueur, minimum 1)
    - Appelle `modules.infligerDegatsAuJoueur()`
    - Si PV joueur <= 0, appelle `finCombat('monstre')`
- **Attaque directe** :
  - `attaqueMonstre(valeur)` (combat_manager_logic.js) :
    - Applique les dégâts au monstre via `appliquerDegatsAuMonstre()`
    - Si PV monstre <= 0, appelle `finCombat('joueur')`

## 4. Fin du Combat
- `finCombat(vainqueur)` (combat_manager_logic.js) :
  - Désactive le mode combat
  - Nettoie la boucle d’attaque automatique
  - Si vainqueur = 'monstre', affiche le Game Over
  - Si vainqueur = 'joueur', donne l’XP via `gainXP()`

## 5. Fonctions Utilitaires et Modules
- **Modules** :
  - Les modules (modules_main_logic.js) centralisent les accès aux fonctions de gestion du joueur, du monstre, des talents, etc.
  - Exemples : `getPlayerAtk()`, `getPlayerDef()`, `getMonstreParId()`, `applyStatusEffect()`, etc.

## 6. Liens entre Fonctions (Résumé)
- Mouvement joueur → (si monstre détecté) → `triggerCombatIfNeeded()` ou `verifierRencontre()`
- → `demarrerCombat()` → boucle attaque monstre → `attaqueJoueur()`
- → Joueur attaque par talent → `utiliserTalent()` → `recevoirDegats()`
- → Dégâts appliqués au monstre → `attaqueMonstre()`
- → Si PV <= 0 → `finCombat()`

## 7. Système de progression et leveling

### a. Gain d'expérience (XP)
- Le joueur gagne de l'XP principalement en battant des monstres.
- La quantité d'XP gagnée dépend du niveau du monstre (`getMonsterXP(level)` dans progression_main_logic.js).
- Après chaque victoire, `gainXP(amount)` (player_main_logic.js) est appelée.

### b. Calcul du seuil pour le niveau suivant
- Le seuil d'XP pour passer au niveau suivant est calculé par `getXpToNextLevel(level)` (progression_main_logic.js).
  - Formule : XP_niveau_suivant = floor(10 * 1.5^(niveau-1))
- Quand l'XP accumulée dépasse ce seuil, la fonction `levelUp()` est appelée.

### c. Effets d'une montée de niveau (level up)
- `levelUp()` (player_main_logic.js) :
  - Décrémente l'XP du joueur du seuil atteint
  - Incrémente le niveau du joueur
  - Réinitialise les stats principales via `initialiserStatsJoueur()`
  - Affiche une notification visuelle
  - Réinitialise les talents disponibles via `initialiserTalents()`
  - Met à jour la barre d'XP
- Les stats principales (PV max, mana max, attaque, défense) sont recalculées selon le niveau et la classe (`getMaxVie()`, `getMaxMana()`, etc.)
- De nouveaux talents peuvent être débloqués selon le niveau (`filterTalentsByLevel()` et `onLevelUp()` dans progression_main_logic.js)

### d. Limite de niveau
- Le niveau maximal est fixé à 10 dans la logique actuelle.
- Si le joueur atteint ce niveau, l'XP est plafonnée et il n'y a plus de gain de niveau.

### e. Sauvegarde et chargement
- Le niveau et l'XP sont sauvegardés côté serveur (player_manager.py) et côté client (`getPlayerSaveData()`)
- Lors du chargement, les fonctions `loadPlayerData()` restaurent le niveau, l'XP et recalculent les stats.

### f. Fonctions et modules impliqués
- JS : `gainXP`, `levelUp`, `getXpToNextLevel`, `getMonsterXP`, `getMaxVie`, `getMaxMana`, `filterTalentsByLevel`, `onLevelUp`, `setPlayerLevel`, `setPlayerXP`, `updateXPBar`, `initialiserStatsJoueur`, `initialiserTalents`
- Python : `PlayerManager.add_experience()`

---

Ce système permet une progression fluide, avec montée de stats et de talents à chaque niveau, et une gestion centralisée de l'XP et du niveau côté client et serveur.

## 8. Variables Globales Importantes
- `combatActif`, `currentMonstre`, `monstreInterval` (combat_manager_logic.js)
- `state` (player_state_logic.js) : stocke PV, mana, stats joueur

## 9. Évolutions Possibles
- Ajout de nouveaux effets de statut (brûlure, stun, etc.) via les modules
- IA de monstre plus complexe (compétences, buffs)
- Gestion multi-monstres simultanés

## 10. Système de Talents

### a. Déblocage et accès aux talents
- Les talents sont définis par classe et par niveau dans le fichier `static/talents/talents.json`.
- Au chargement ou lors d'un level up, les talents accessibles sont filtrés :
  - Par la fonction `filterTalentsByLevel(allTalents, playerLevel)` (progression_main_logic.js)
  - Par la fonction `getTalents()` (player_talents_logic.js), qui retourne les talents de la classe du joueur et de niveau suffisant.
- De nouveaux talents sont débloqués automatiquement à certains niveaux (`niveauRequis` dans le JSON).

### b. Activation des talents
- Chaque talent est associé à une touche du clavier (voir KEY_MAP dans input_handler_logic.js).
- Lorsqu'une touche est pressée :
  - `handleKeydown()` vérifie si un talent est disponible à cette touche et appelle `utiliserTalent(talent, index)`.
- Les conditions d'activation sont vérifiées :
  - Cooldown individuel (pas d'activation si le talent est en recharge)
  - Coût en mana (pas d'activation si mana insuffisant)

### c. Effets et types de talents
- Les talents peuvent avoir différents effets selon leur type :
  - **attack** : inflige des dégâts directs à un ou plusieurs monstres
  - **heal** : soigne le joueur
  - **boost**/**utility** : applique un effet temporaire (ex : poison, stun, bouclier, buff/débuff, furtivité, dash...)
  - **defense** : accorde un bouclier ou une protection temporaire
- Les effets sont appliqués via des fonctions utilitaires : `applyStatusEffect`, `applyBoost`, etc.
- Certains talents ont des effets visuels (couleur, opacité, texte d'effet)
- Les talents peuvent cibler une zone (adjacent, ligne, etc.)

### d. Gestion des cooldowns et de la mana
- Chaque talent possède un attribut `cooldown` (ms) et `cost` (mana).
- Un tableau `cooldowns[]` gère l'état de recharge de chaque talent côté client.
- Après activation, le talent ne peut plus être utilisé jusqu'à la fin du cooldown.

### e. Fonctions principales impliquées
- JS :
  - `getTalents`, `getAllTalentsList`, `filterTalentsByLevel`, `utiliserTalent`, `dashStealth`, `initialiserTalents`, `applyStatusEffect`, `applyBoost`, `updatePlayerStatsPanel`, `handleKeydown`
- Python :
  - `load_talents(classe)` (routes.py) : charge les talents d'une classe depuis le JSON côté serveur

### f. Sauvegarde
- Les talents débloqués peuvent être sauvegardés dans la progression du joueur (selon l'implémentation côté client/serveur)

---

Le système de talents permet une personnalisation avancée du gameplay, chaque classe ayant ses propres compétences à débloquer et à utiliser stratégiquement en combat.

---

Pour toute modification, se référer à ce fichier pour comprendre l’enchaînement des appels et l’emplacement des logiques principales.
